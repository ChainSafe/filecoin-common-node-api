/// This code is generated by the `openrpc generate` subcommand.
// TODO(aatifsyed): this could be put in a separate crate to improve compile times
mod generated;

use std::{
    any::type_name,
    collections::BTreeSet,
    convert::Infallible,
    fmt,
    io::Read as _,
    panic::{self, AssertUnwindSafe, PanicInfo},
    time::Duration,
};

use bstr::BString;
use ez_jsonrpc::{
    params::SerializePositional,
    types::{self as jsonrpc, RequestParameters},
};
use serde::de::DeserializeOwned;
use tracing::{debug, info, info_span};

/// Represents that a single test has failed - the runner may stop running.
///
/// This SHOULD be propogated with the `?` operator.
// This is a shim of anyhow::Error to enforce semantics.
// We hide Send + Sync + 'static bounds for messages to hide complexity.
pub struct TestFailure(anyhow::Error);

impl TestFailure {
    pub fn msg(msg: impl fmt::Display) -> Self {
        Self(anyhow::Error::msg(msg.to_string()))
    }
    pub fn context(self, msg: impl fmt::Display) -> Self {
        Self(self.0.context(msg.to_string()))
    }
    /// See [`Ctx::call`].
    pub fn as_rpc_error(&self) -> Option<&jsonrpc::Error> {
        self.0.downcast_ref()
    }
    #[doc(hidden)]
    #[deprecated = "not public API"]
    pub fn __new(e: anyhow::Error) -> Self {
        Self(e)
    }
}

impl<T> From<T> for TestFailure
where
    T: std::error::Error + Send + Sync + 'static,
{
    fn from(value: T) -> Self {
        Self(value.into())
    }
}

mod sealed {
    pub trait Sealed {}
    impl<T, E> Sealed for Result<T, E> {}
    impl<T> Sealed for Option<T> {}
}

/// Utility trait for failing a test on a [`Result::Err`] or [`Option::None`].
pub trait Context<T, E>: sealed::Sealed {
    fn context<C: fmt::Display>(self, context: C) -> Result<T, TestFailure>;
}

impl<T, E> Context<T, E> for Result<T, E>
where
    E: std::error::Error + Send + Sync + 'static,
{
    fn context<C: fmt::Display>(self, context: C) -> Result<T, TestFailure> {
        anyhow::Context::context(self, context.to_string()).map_err(TestFailure)
    }
}

impl<T> Context<T, Infallible> for Option<T> {
    fn context<C: fmt::Display>(self, context: C) -> Result<T, TestFailure> {
        anyhow::Context::context(self, context.to_string()).map_err(TestFailure)
    }
}

/// Create a test case.
///
/// `name` SHOULD be unique.
pub fn test<'a>(
    name: impl Into<String>,
    f: impl FnOnce(&mut Ctx) -> Result<(), TestFailure> + 'a,
) -> Test<'a> {
    Test {
        name: name.into(),
        runner: Box::new(f),
    }
}

/// Dynamic test case, created with the [`test`] function.
pub struct Test<'a> {
    name: String,
    #[allow(clippy::type_complexity)]
    runner: Box<dyn FnOnce(&mut Ctx) -> Result<(), TestFailure> + 'a>,
}

/// Closed set of tags for the test suite.
#[derive(strum::Display, strum::EnumString, PartialEq, Eq, PartialOrd, Ord, Debug)]
#[strum(serialize_all = "snake_case")]
pub enum Tag {}

/// Context for a [`Test`].
///
/// You may use this to:
/// - Send and receive JSON-RPC requests.
/// - Request resources like snapshots from the runner.
/// - Categorize your test.
#[derive(Debug)]
pub struct Ctx {
    client: reqwest::blocking::Client,
    url: String,
    id: u64,
    current_test_tags: BTreeSet<Tag>,
    log: Vec<Log>,

    harness_tags: Option<BTreeSet<Tag>>,

    done_first_call: bool,

    timeout_mode: Timeout,
    harness_timeout_default: Duration,
    harness_timeout_long: Duration,

    auth_mode: Auth,
    harness_auth_bad: String,
    harness_auth_good: String,
}

#[derive(Debug, Clone, Copy)]
enum Timeout {
    Default,
    Long,
}

#[derive(Debug, Clone, Copy)]
enum Auth {
    None,
    Bad,
    Good,
}

impl Ctx {
    fn filter(&self) -> Result<(), Ignored> {
        match &self.harness_tags {
            Some(filter) if !filter.is_subset(&self.current_test_tags) => return Err(Ignored),
            _ => Ok(()),
        }
    }

    /// Apply tags to this [`Test`].
    ///
    /// This MUST be done before any JSON-RPC method calls,
    /// and SHOULD NOT be conditional.
    #[allow(private_bounds)]
    pub fn tag(&mut self, tags: impl TagCtx) -> &mut Self {
        assert!(
            !self.done_first_call,
            "Ctx::tag must be called before any method calls"
        );
        tags.tag_ctx(&mut self.current_test_tags);
        self
    }

    /// [`Self::call`]s after this will use a longer timeout.
    pub fn long_timeout(&mut self) {
        self.timeout_mode = Timeout::Long
    }

    /// [`Self::call`]s after this will use the default timeout.
    pub fn normal_timeout(&mut self) {
        self.timeout_mode = Timeout::Default
    }

    /// [`Self::call`]s after this will be unauthorised.
    pub fn no_auth(&mut self) {
        self.auth_mode = Auth::None
    }
    /// [`Self::call`]s after this will have authorisation.
    /// (This is the default).
    pub fn good_auth(&mut self) {
        self.auth_mode = Auth::Good
    }
    /// [`Self::call`]s after this will have malformed authorisation.
    pub fn bad_auth(&mut self) {
        self.auth_mode = Auth::Bad
    }

    /// Call a JSON-RPC method.
    ///
    /// JSON-RPC [specifies an error object](https://www.jsonrpc.org/specification#error_object)
    /// that all methods may return.
    ///
    /// Such errors are assumed to _also_ be [`TestFailure`]s -
    /// you may manually check to see if a method returned an error by calling
    /// [`TestFailure::as_rpc_error`].
    pub fn call<T: DeserializeOwned>(
        &mut self,
        method: impl Into<String>,
        args: impl SerializePositional,
    ) -> Result<T, TestFailure> {
        self.done_first_call = true;
        self.filter()?;

        self.id += 1;
        let request_id = jsonrpc::Id::Number(self.id.into());
        let request = jsonrpc::Request {
            method: method.into(),
            params: Some(RequestParameters::ByPosition(
                args.ser_positional(ez_jsonrpc::params::ser::ByPosition::new())
                    .context("couldn't serialize params")?,
            )),
            id: Some(request_id.clone()),
        };
        debug!(target: { target::INFRA },?request);
        let builder = self
            .client
            .post(&self.url)
            .json(&request)
            .timeout(match self.timeout_mode {
                Timeout::Default => self.harness_timeout_default,
                Timeout::Long => self.harness_timeout_long,
            });

        let mut resp = match self.auth_mode {
            Auth::None => builder,
            Auth::Bad => builder.bearer_auth(&self.harness_auth_bad),
            Auth::Good => builder.bearer_auth(&self.harness_auth_good),
        }
        .send()
        .context("couldn't send HTTP request")?;
        let mut body = BString::default();
        resp.read_to_end(&mut body)
            .context("couldn't collect HTTP response body from server")?;
        match (
            resp.error_for_status().context("HTTP error from server"),
            serde_json::from_slice::<jsonrpc::Response>(&body)
                .context("invalid JSON-RPC response from server"),
        ) {
            (Err(e), _) | (_, Err(e)) => {
                debug!(target: { target::INFRA }, ?body);
                Err(e)
            }
            (_, Ok(response)) => {
                debug!(target: { target::INFRA }, ?response);
                if request_id != response.id {
                    fail!("server violated the JSON-RPC protocol (member `id` does not match)")
                }
                let o = response.result.context("JSON-RPC call returned an error")?;
                let o = T::deserialize(o).context(format!(
                    "couldn't deserialize JSON-RPC response into a {}",
                    type_name::<T>()
                ))?;
                Ok(o)
            }
        }
    }
}

pub struct Args {
    /// Only run the test with the given name.
    pub name: Option<String>,
    /// If [`Some`], only run [`Test`]s which contain all of the given [`Tag`]s.
    pub tags: Option<BTreeSet<Tag>>,
    pub url: String,
    pub default_timeout: Duration,
    pub long_timeout: Duration,
    pub auth: String,
    pub bad_auth: String,
}

/// Run the given test cases.
///
/// This SHOULD only be called once, unconditionally.
pub fn run<'a>(tests: impl IntoIterator<Item = Test<'a>>, args: Args) {
    let mut tests = tests.into_iter().collect::<Vec<_>>();
    tests.sort_by_cached_key(|it| it.name.clone());

    let Args {
        name: filter_name,
        tags,
        url,
        default_timeout,
        long_timeout,
        auth,
        bad_auth,
    } = args;

    let mut skipped = 0;
    let mut succeeded = 0;
    let mut failed = 0;

    let mut ctx = Ctx {
        client: reqwest::blocking::Client::builder()
            .user_agent(concat!(
                env!("CARGO_PKG_NAME"),
                "/",
                env!("CARGO_PKG_VERSION")
            ))
            .build()
            .expect("couldn't initialize client"),
        url,
        log: vec![],

        id: 0,
        current_test_tags: BTreeSet::new(),
        harness_tags: tags,
        done_first_call: false,

        timeout_mode: Timeout::Default,
        harness_timeout_default: default_timeout,
        harness_timeout_long: long_timeout,

        auth_mode: Auth::Good,
        harness_auth_bad: bad_auth,
        harness_auth_good: auth,
    };

    // TODO(aatifsyed): siphon off a backtrace and log it
    panic::set_hook(Box::new(|_| {}));
    for Test { name, runner } in tests {
        let _span = info_span!(target: { target::RUNTIME }, "test", %name).entered();
        let res = match &filter_name {
            Some(filter_name) => match name == *filter_name {
                true => {
                    info!(target: { target::RUNTIME }, "start");
                    panic::catch_unwind(AssertUnwindSafe(|| runner(&mut ctx)))
                }
                false => {
                    info!(target: { target::RUNTIME }, "skipped (name)");
                    skipped += 1;
                    continue;
                }
            },
            None => {
                info!(target: { target::RUNTIME }, "start");
                panic::catch_unwind(AssertUnwindSafe(|| runner(&mut ctx)))
            }
        };
        match res {
            Ok(Ok(())) => {
                info!(target: { target::RUNTIME }, "succeeded");
                succeeded += 1;
            }
            Ok(Err(TestFailure(e))) => match e.downcast_ref::<Ignored>() {
                Some(_) => {
                    info!(target: { target::RUNTIME }, "skipped (tag)");
                    skipped += 1
                }
                None => {
                    let errors = e.chain().map(ToString::to_string).collect::<Vec<_>>();
                    info!(target: { target::RUNTIME }, ?errors, "failed");
                    failed += 1
                }
            },
            Err(panic) => {
                let panic_msg = match (panic.downcast_ref::<String>(), panic.downcast_ref::<&str>())
                {
                    (Some(s), _) => s.as_str(),
                    (_, Some(s)) => s,
                    _ => "Box<dyn Any>",
                };
                info!(target: { target::RUNTIME }, %panic_msg, "failed");
                failed += 1
            }
        }

        ctx.current_test_tags.clear();
        ctx.done_first_call = false;
        ctx.auth_mode = Auth::Good;
        ctx.timeout_mode = Timeout::Default;
    }
    let _unregister = panic::take_hook();

    todo!()
}

#[derive(thiserror::Error, Debug)]
#[error("ignored")]
struct Ignored;

/// Utility trait to allow [`Ctx::tag`] to accept either a single [`Tag`] or a
/// collection of many.
trait TagCtx {
    fn tag_ctx(self, tags: &mut BTreeSet<Tag>);
}

impl TagCtx for Tag {
    fn tag_ctx(self, tags: &mut BTreeSet<Tag>) {
        tags.insert(self);
    }
}

impl<T> TagCtx for T
where
    T: IntoIterator<Item = Tag>,
{
    fn tag_ctx(self, tags: &mut BTreeSet<Tag>) {
        tags.extend(self)
    }
}

macro_rules! fail {
    ($msg:literal $(,)?) => {
        #[allow(deprecated)]
        return ::core::result::Result::Err($crate::test::TestFailure::__new(::anyhow::anyhow!($msg)))
    };
    ($err:expr $(,)?) => {
        #[allow(deprecated)]
        return ::core::result::Result::Err($crate::test::TestFailure::__new(::anyhow::anyhow!($err)))
    };
    ($fmt:expr, $($arg:tt)*) => {
        #[allow(deprecated)]
        return ::core::result::Result::Err($crate::test::TestFailure::__new(::anyhow::anyhow!($fmt, $($arg)*)))
    };
}
pub(crate) use fail;

#[derive(Debug)]
enum Log {
    User(String),
    Request(jsonrpc::Request),
    Response(jsonrpc::Response),
    Body(BString),
}

mod target {
    pub const RUNTIME: &str = "runtime";
    pub const INFRA: &str = "infra";
}
